//: # Курс "Swift-Drift" от [SnapBlog](http://snapblog.ru)
//:
//: ## Классы и Инициализаторы
//:
//: В объектно-ориентированном программировании, поведение программы во многом основано на взаимодействии между объектами. _Объект_ является экземпляром _класса_, который может рассматриваться в качестве основы для этого объекта. Классы содержат дополнительную информацию о себе в виде _свойств_, и определяют свое поведения с помощью методов.
//:
//: Используйте `class` с последующим именем класса, чтобы определить класс. Объявление свойств класса записывается так же, как объявление констант или переменных, за исключением того, что это происходит внутри класса. Аналогично, объявление метода записывается так же, как объявление функции. В данном примере объявляется класс `Shape` со свойством `numberOfSides` и методом `simpleDescription()`.
//:
class Shape {
    var numberOfSides = 0
    func simpleDescription() -> String {
        return "A shape with \(numberOfSides) sides."
    }
}

//: Создать экземпляр объект класса можно, поставив круглые скобки после имени класса. Используйте точечный синтаксис для доступа к свойствам и методам экземпляра. Здесь, `shape` является объектом, который является экземпляром класса `Shape`.
//:
var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()

//: Данный класс `Shape` не содержит кое что важное: инициализатор. _Инициализатор_ это метод, который подготавливает экземпляр класса для использования, включающий в себя настройки начальных значений для каждого свойства и выполняет разные другие настройки. Используйте `init`, чтобы создать инициализатор. Этот пример определят новый класс, `NamedShape`, который имеет инициализатор, применяемый к имени (name).
//:
class NamedShape {
    var numberOfSides = 0
    var name: String

    init(name: String) {
       self.name = name
    }

    func simpleDescription() -> String {
       return "A shape with \(numberOfSides) sides."
    }
}

//: Обратите внимание, как `self` используется для того, чтобы отличить свойство `name` от аргумента `name` в инициализаторе. Каждое свойство должно содержать присваиваемое значение либо в своем заявлении (как в случае с `numberOfSides`) или в инициализаторе (как в случае с `name`).
//:
//: Вы не взываете инициализатор при написании `init`; вы вызываете его, при вставке в скобки соответствующих аргументов после имени класса. Когда вы вызываете инициализатор, вы вписываете все имена аргументов вместе с их значениями. 
//:
let namedShape = NamedShape(name: "SnapBlog")

//: Классы _наследуют_ (_inherit_) их поведение от родительского класса. Класс, который наследует поведение другого класса, называется _подклассом_ (_subclass_) класса, и родительский класс называют _суперклассом_ (_superclass_). Подклассы содержат имя суперкласса после своего имени, разделенных двоеточием. Класс может наследоваться только от одного класса, хотя это класс может наследоваться от другого суперкласса, и так далее, что приведет к _иерархии классов_.
//:
//: Методы подкласса, которые _переопределяют_ реализацию суперкласса помечаются как `override` — случайное переопределение методов, без `override`, обнаруживается компилятором как ошибка. Компилятор также обнаружит методы с `override` как ошибку, которые на самом деле не переопределяют какой-либо метод суперкласса.
//:
//: В данном мере определяется класс `Square`, являющийся подклассом `NamedShape`.
//:
class Square: NamedShape {
    var sideLength: Double

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 4
    }

    func area() ->  Double {
        return sideLength * sideLength
    }

    override func simpleDescription() -> String {
        return "A square with sides of length \(sideLength)."
    }
}
let testSquare = Square(sideLength: 5.2, name: "my test square")
testSquare.area()
testSquare.simpleDescription()

//: Обратите внимание, что инициализатор для класса `Square` содержит три различных действия:
//:
//: 1. Установка значения свойства, которое объявляет подкласс `Square` (для свойства sideLength).
//:
//: 2. Вызов инициализатора суперкласса `NamedShape`.
//:
//: 3. Изменение значения свойства определенного в суперклассе `NamedShape`.
//:
//: Иногда, инициализация объекта нужна обязательно, например, когда значения, получаемые в качестве аргументов, находятся за пределами определенного диапазона, или когда данные, как ожидается, могут отсутствовать. Некоторые инициализаторы, которые могут не выполниться, называют _failable initializer_ (инициализаторы, которые могут потерпеть неудачу при выполнении). Такие инициализаторы могут возвратить `nil` после инициализации. Используйте `init?` для объявления таких инициализаторов.
//:
class Circle: NamedShape {
    var radius: Double

    init?(radius: Double, name: String) {
        self.radius = radius
        super.init(name: name)
        numberOfSides = 1
        if radius <= 0 {
            return nil
        }
    }

    override func simpleDescription() -> String {
        return "A circle with a radius of \(radius)."
    }
}
let successfulCircle = Circle(radius: 4.2, name: "successful circle")
let failedCircle = Circle(radius: -7, name: "failed circle")

//: Инициализаторы могут иметь довольно много ключевых слов (keywords), связанных с ними. _Назначенный инициализатор_ (_designated initializer_) указывает, что это один из основных инициализаторов для класса; каждый класс должен иметь хотя бы один назначенный инициализатор. В некоторых случаях, это требование удовлетворяется наследованием одного или более назначенных инициализаторов от суперкласса. _Вспомогательные инициализаторы_ (_convenience initializer_) являются вторичными, поддерживающими инициализаторами, которые добавляют дополнительное поведение или настройки для класса. Вспомогательный инициализатор в конечном счете должен вызывать назначенный инициализатор. Назначенные и вспомогательные инициализаторы обозначаются с ключевыми словами `designated` и `convenience`, соответственно.
//:
//: Ключевое слово`required` перед определением инициализатора класса означает, что каждый подкласс этого класса должен реализовать собственную версию этого инициализатора.
//:
//: _Приведение типов_ - это способ проверить тип экземпляра и/или способ обращения к экземпляру так, как если бы он был экземпляром суперкласса или подкласса откуда-либо из своей собственной классовой иерархии.
//:
//: Константа или переменная определенного класса может фактически ссылаться на экземпляр подкласса. Когда вы заметили, что это так, вы можете попробовать _привести_ тип к типу подкласса при помощи оператора понижающего приведения (`as?` или `as!`).
//:
//: Из-за того, что понижающее приведение может провалиться, оператор приведения имеет две формы. Опциональная форма `as?`, которая возвращает опциональное значение типа, к которому вы пытаетесь привести. И принудительная форма `as!`, которая принимает попытки понижающего приведения и принудительного разворачивания результата в рамках одного составного действия.
//:
//: Используйте _опциональную форму оператора понижающего приведения_ (`as?`), когда вы не уверены, что ваше понижающее приведение выполнится успешно. В этой форме оператор всегда будет возвращать опциональное значение, и значение будет `nil` , если понижающее приведение будет не выполнимо. Так же это позволяет вам проверить успешность понижающего приведения типа.
//:
//: Используйте _принудительную форму оператора понижающего приведения_ (`as!`) , но только в тех случаях, когда вы точно уверены, что понижающее приведение будет выполнено успешно. Эта форма оператора вызовет runtime ошибку, если вы попытаетесь таким образом привести к некорректному типу класса.
//:
//: Этот пример показывает использование опциональной формы оператора понижающего приведения (`as?`) чтобы проверить, является ли форма в массиве формой круга или квадрата. Вы увеличиваете значения счетчиков `squares` и `triangles` (переменных) на единицу каждый раз, когда соответствующая форма найдена и выводит значение в конце.
//:
class Triangle: NamedShape {
    init(sideLength: Double, name: String) {
        super.init(name: name)
        numberOfSides = 3
    }
}

let shapesArray = [Triangle(sideLength: 1.5, name: "triangle1"), Triangle(sideLength: 4.2, name: "triangle2"), Square(sideLength: 3.2, name: "square1"), Square(sideLength: 2.7, name: "square2")]
var squares = 0
var triangles = 0
for shape in shapesArray {
   if let square = shape as? Square {
      squares++
   } else if let triangle = shape as? Triangle {
      triangles++
   }
}
print("\(squares) squares and \(triangles) triangles.")

//: > **Эксперимент**:
//: > Попробуйте заменить `as?` на `as!`. Какую ошибку вы получите?
//:
//: [Назад](@previous) | [Далее](@next)
//:
//: [SnapBlog](http://snapblog.ru)
